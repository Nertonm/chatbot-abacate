name: CI/CD - Release, Build, e Deploy PR

# GATILHO: Executa apenas quando uma tag no formato v*.*.* (ex: v1.0.0) é criada
on:
  push:
    tags:
      - 'v*.*.*'

env:
  IMAGE_REGISTRY: docker.io
  IMAGE_NAME: nerton/chatbot-abacate                 
  MANIFESTS_REPO: Nertonm/chatbot-manifests       
  MANIFESTS_FILE_PATH: deployment-app.yaml

jobs:
  # JOB 1: Construir a imagem e enviar para o Docker Hub
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      # Exporta a tag da imagem para o próximo job usar
      image_tag: ${{ steps.meta.outputs.version }}
    steps:
      - name: 1. Checkout do código da aplicação
        uses: actions/checkout@v4

      - name: 2. Login no Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USER }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: 3. Extrair metadados da imagem (Tags e Labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=semver,pattern={{version}}

      - name: 4. Configurar Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 5. Buildar e Publicar Imagem Docker
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=inline
          cache-to: type=inline,mode=max

  # JOB DE QUALIDADE DE CÓDIGO (NOVO)
  sonar-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout do código
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Importante: Shallow clones podem desativar algumas regras do Sonar

      - name: SonarQube Scan
        uses: sonarsource/sonarqube-scan-action@v4
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

  # JOB 2: Criar o Pull Request no Repositório de Manifestos
  create-deploy-pr:
    runs-on: ubuntu-latest
    # Garante que este job só rode APÓS o 'build-and-push' ser concluído
    needs: build-and-push
    steps:
      - name: 1. Checkout do repositório de MANIFESTOS (usando token)
        uses: actions/checkout@v4
        with:
          # Usa o repo de manifestos definido na variável 'env'
          repository: ${{ env.MANIFESTS_REPO }}
          # Salva o repo dentro de uma subpasta 'manifests' no workspace
          path: manifests
          # Usa um Personal Access Token (PAT) armazenado em secrets para autenticação
          token: ${{ secrets.MANIFESTS_TOKEN }}

      - name: 2. Atualizar o arquivo de deployment.yaml
        run: |
          # Pega a tag da imagem do job anterior (substituído em tempo de template)
          IMAGE_TAG=${{ needs.build-and-push.outputs.image_tag }}

          # Define o nome completo da imagem
          NEW_IMAGE="${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}"

          # Caminho relativo que deve ser informado via env MANIFESTS_FILE_PATH
          FILE_REL="${{ env.MANIFESTS_FILE_PATH }}"

          if [ -z "${FILE_REL}" ]; then
            echo "ERROR: MANIFESTS_FILE_PATH não está definido. Defina 'MANIFESTS_FILE_PATH' no workflow env ou como variável de repositório (ex: k8s/deployment-app.yaml)"
            exit 1
          fi

          # Caminho final dentro do workspace onde o repo de manifestos foi checado
          FILE_PATH="manifests/${FILE_REL}"

          echo "Atualizando a imagem em ${FILE_PATH} para ${NEW_IMAGE}"

          # Debug: liste o diretório para ajudar na investigação caso falhe
          echo "Conteúdo de manifests/:"
          ls -la manifests || true

          # Verifica se o arquivo existe e é um arquivo regular antes de editar
          if [ ! -f "${FILE_PATH}" ]; then
            echo "ERROR: Arquivo alvo não encontrado ou não é um arquivo regular: ${FILE_PATH}"
            exit 1
          fi

          # Usa 'sed' para substituir a linha 'image:' no arquivo alvo
          sed -i -E "s|image: .*|image: ${NEW_IMAGE}|g" "${FILE_PATH}"

          # Mostra diff para confirmar a alteração
          git --no-pager --no-color diff -- "${FILE_PATH}" || true

      - name: 3. Criar Pull Request com as alterações
        uses: peter-evans/create-pull-request@v6
        with:
          # Informa a action para trabalhar dentro da pasta onde o repo foi checado
          path: manifests
          # Usa token para autenticação ao criar o PR no repo de manifestos
          token: ${{ secrets.MANIFESTS_TOKEN }}
          
          # Configurações do Git
          commit-message: "ci: Atualiza imagem para ${{ needs.build-and-push.outputs.image_tag }}"
          author: "GitHub Actions <actions@github.com>"
          committer: "GitHub Actions <actions@github.com>"
          
          # Configurações do PR
          title: "CI: Deploy da imagem ${{ needs.build-and-push.outputs.image_tag }}"
          body: |
            Pull Request automático para atualizar a imagem da aplicação para a versão **${{ needs.build-and-push.outputs.image_tag }}**.
            
            Este PR foi gerado pelo workflow de CI/CD.
          branch: "auto/update-image-${{ needs.build-and-push.outputs.image_tag }}"
          base: main 